{
  "title": "Find Missing Positive Integer",
  "description": "Given an unsorted integer array nums, return the smallest positive integer that is not present in nums.",
  "examples": [
    {
      "input": "[1,2,0]",
      "output": "3",
      "explanation": "The numbers in the range [1,2] are all in the array."
    },
    {
      "input": "[3,4,-1,1]",
      "output": "2",
      "explanation": "1 is in the array but 2 is missing."
    }
  ],
  "constraints": [
    "1 <= nums.length <= 10^5",
    "-2^31 <= nums[i] <= 2^31 - 1"
  ],
  "answer_python": {
    "code": "def firstMissingPositive(nums):\n    n = len(nums)\n    for i in range(n):\n        while 1 <= nums[i] <= n and nums[nums[i] - 1] != nums[i]:\n            nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1]\n    for i in range(n):\n        if nums[i] != i + 1:\n            return i + 1\n    return n + 1",
    "explanation": "The function firstMissingPositive iterates over the array to put each number in its correct position. Then, it checks for the first missing positive integer by iterating over the array again."
  },
  "answer_cpp": {
    "code": "#include <vector>\nint firstMissingPositive(std::vector<int>& nums) {\n    int n = nums.size();\n    for (int i = 0; i < n; ++i) {\n        while (1 <= nums[i] && nums[i] <= n && nums[nums[i] - 1] != nums[i]) {\n            std::swap(nums[nums[i] - 1], nums[i]);\n        }\n    }\n    for (int i = 0; i < n; ++i) {\n        if (nums[i] != i + 1) {\n            return i + 1;\n        }\n    }\n    return n + 1;\n}",
    "explanation": "The function firstMissingPositive iterates over the vector to put each number in its correct position. Then, it checks for the first missing positive integer by iterating over the vector again."
  },
  "sent": "false"
}
