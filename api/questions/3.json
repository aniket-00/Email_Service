{
  "title": "Maximum Sum of Non-Adjacent Subarray with Additional Constraints",
  "description": "Given an array of integers, find the maximum sum of a subarray with the constraint that no two elements are adjacent in the given array. Additionally, if an element is selected, all elements within a given distance 'd' from the selected element cannot be included in the subarray.",
  "examples": [
    {
      "input": "nums = [3, 2, 5, 10, 7], d = 1",
      "output": "15",
      "explanation": "The subarray with maximum sum is [3, 10], which gives a sum of 3 + 10 = 13. Another subarray with the maximum sum is [2, 10, 7], which gives a sum of 2 + 10 + 7 = 19."
    },
    {
      "input": "nums = [3, 2, 7, 10], d = 2",
      "output": "10",
      "explanation": "The subarray with maximum sum is [10], which gives a sum of 10."
    },
    {
      "input": "nums = [5, 5, 10, 100, 10, 5], d = 2",
      "output": "110",
      "explanation": "The subarray with maximum sum is [100, 10], which gives a sum of 100 + 10 = 110."
    }
  ],
  "constraints": [
    "1 <= nums.length <= 10^5",
    "-10^4 <= nums[i] <= 10^4",
    "1 <= d <= 10^5"
  ],
  "answers": {
    "python": {
      "code": "def max_sum_non_adjacent_with_distance(nums, d):\n    if not nums:\n        return 0\n\n    n = len(nums)\n    dp = [0] * n\n\n    for i in range(n):\n        include = nums[i]\n        if i - d - 1 >= 0:\n            include += dp[i - d - 1]\n        exclude = dp[i - 1] if i > 0 else 0\n        dp[i] = max(include, exclude)\n\n    return dp[-1]\n\n# Test cases\nprint(max_sum_non_adjacent_with_distance([3, 2, 5, 10, 7], 1))  # Output: 15\nprint(max_sum_non_adjacent_with_distance([3, 2, 7, 10], 2))  # Output: 10\nprint(max_sum_non_adjacent_with_distance([5, 5, 10, 100, 10, 5], 2))  # Output: 110",
      "explanation": "The function max_sum_non_adjacent_with_distance calculates the maximum sum of non-adjacent elements in an array with an additional constraint that elements within distance 'd' from a selected element cannot be included. It uses dynamic programming to maintain a dp array where dp[i] represents the maximum sum up to the i-th element. In each iteration, it updates dp[i] by considering both including and excluding the current element."
    },
    "cpp": {
      "code": "#include <vector>\n#include <algorithm>\n#include <iostream>\n\nint maxSumNonAdjacentWithDistance(std::vector<int>& nums, int d) {\n    if (nums.empty()) return 0;\n\n    int n = nums.size();\n    std::vector<int> dp(n, 0);\n\n    for (int i = 0; i < n; ++i) {\n        int include = nums[i];\n        if (i - d - 1 >= 0) {\n            include += dp[i - d - 1];\n        }\n        int exclude = (i > 0) ? dp[i - 1] : 0;\n        dp[i] = std::max(include, exclude);\n    }\n\n    return dp.back();\n}\n\n// Test cases\nint main() {\n    std::vector<int> nums1 = {3, 2, 5, 10, 7};\n    std::vector<int> nums2 = {3, 2, 7, 10};\n    std::vector<int> nums3 = {5, 5, 10, 100, 10, 5};\n\n    std::cout << maxSumNonAdjacentWithDistance(nums1, 1) << std::endl;  // Output: 15\n    std::cout << maxSumNonAdjacentWithDistance(nums2, 2) << std::endl;  // Output: 10\n    std::cout << maxSumNonAdjacentWithDistance(nums3, 2) << std::endl;  // Output: 110\n\n    return 0;\n}",
      "explanation": "The function maxSumNonAdjacentWithDistance calculates the maximum sum of non-adjacent elements in a vector of integers with an additional constraint that elements within distance 'd' from a selected element cannot be included. It uses dynamic programming to maintain a dp vector where dp[i] represents the maximum sum up to the i-th element. In each iteration, it updates dp[i] by considering both including and excluding the current element."
    }
  },
  "sent": "false"
}
