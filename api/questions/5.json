{
  "title": "Maximum Area of Island",
  "description": "Given a grid of 0's and 1's, where 0 represents water and 1 represents land, find the maximum area of an island in the grid. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically.",
  "examples": [
    {
      "input": [
        [0,0,1,0,0,0,0,1,0,0,0,0,0],
        [0,0,0,0,0,0,0,1,1,1,0,0,0],
        [0,1,1,0,1,0,0,0,0,0,0,0,0],
        [0,1,0,0,1,1,0,0,1,0,1,0,0],
        [0,1,0,0,1,1,0,0,1,1,1,0,0],
        [0,0,0,0,0,0,0,0,0,0,1,0,0],
        [0,0,0,0,0,0,0,1,1,1,0,0,0],
        [0,0,0,0,0,0,0,1,1,0,0,0,0]
      ],
      "output": "6",
      "explanation": "The maximum area of an island in the grid is 6, formed by the island with the shaded cells."
    },
    {
      "input": [
        [0,0,0,0,0,0,0,0]
      ],
      "output": "0",
      "explanation": "There are no islands in the grid, so the maximum area is 0."
    }
  ],
  "constraints": [
    "1 <= grid.length, grid[i].length <= 50",
    "grid[i][j] is either 0 or 1."
  ],
  "answers": {
    "python": {
      "code": "def max_area_of_island(grid):\n    def dfs(i, j):\n        if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] == 0:\n            return 0\n        grid[i][j] = 0\n        return 1 + dfs(i+1, j) + dfs(i-1, j) + dfs(i, j+1) + dfs(i, j-1)\n\n    max_area = 0\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == 1:\n                max_area = max(max_area, dfs(i, j))\n    return max_area",
      "explanation": "The function max_area_of_island calculates the maximum area of an island in the grid using depth-first search (DFS) algorithm. It iterates through each cell in the grid and recursively explores neighboring cells to find the area of the island."
    },
    "cpp": {
      "code": "#include <vector>\n\nclass Solution {\npublic:\n    int maxAreaOfIsland(std::vector<std::vector<int>>& grid) {\n        int max_area = 0;\n        for (int i = 0; i < grid.size(); ++i) {\n            for (int j = 0; j < grid[0].size(); ++j) {\n                if (grid[i][j] == 1) {\n                    max_area = std::max(max_area, dfs(grid, i, j));\n                }\n            }\n        }\n        return max_area;\n    }\n\nprivate:\n    int dfs(std::vector<std::vector<int>>& grid, int i, int j) {\n        if (i < 0 || i >= grid.size() || j < 0 || j >= grid[0].size() || grid[i][j] == 0) {\n            return 0;\n        }\n        grid[i][j] = 0;\n        return 1 + dfs(grid, i + 1, j) + dfs(grid, i - 1, j) + dfs(grid, i, j + 1) + dfs(grid, i, j - 1);\n    }\n};",
      "explanation": "The Solution class contains a method maxAreaOfIsland to calculate the maximum area of an island in the grid using depth-first search (DFS) algorithm. It iterates through each cell in the grid and recursively explores neighboring cells to find the area of the island."
    }
  },
  "sent": "false"
}
